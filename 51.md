# Глава 5.1. Установка соединения

Мы уже познакомились с запросами SQL, теперь настало время научиться выполнять их из РНР.

Для работы с БД MySQL в РНР доступны два расширения - универсальное [PHP Data Objects](https://www.php.net/pdo), которое поддерживает работу с множеством разных БД, и [mysqli](https://www.php.net/mysqli), работающее только с MySQL. Хотя в профессиональной разработке практически всегда используется PDO и библиотеки на его базе, на этапе изучения лучше подойдёт mysqli, поскольку позволяет освоить самые базовые приёмы работы с БД и показывает то, как работают все более высокоуровневые библиотеки изнутри. 

# Объектный и процедурный интерфейсы

У Mysqli есть одна уникальная особенность: это расширение реализует как объектный, так и процедурный интерфейс. То есть одну и ту же команду можно выполнить как обратившись к функции, так и к методу объекта:
```php
mysqli_query($mysqli, $query); // процедурный
$mysqli->query($query); // объектный
```
то есть отличие только в том что мы берем параметр функции (`$mysqli`), приписываем к нему объектный оператор `->` и дальше обращаемся к той же функции, отрезав от неё ставшее ненужным слово "mysqli".    

Оба варианта полностью взаимозаменяемы, отличия чисто стилистические. Использовать можно любой. 
Однако поскольку объектный синтаксис выглядит проофессиональнее, плюс процедурный банально длиннее, требуя постоянно повторять одно и то же по два раза (ср. `mysqli_stmt_get_result($stmt)` и `$stmt->get_result()`), то рекомендованным является объектный синтаксис, который мы и будем применять в примерах ниже. 

# Соединение с БД.

При соединении с БД необходимо учитывать три основных момента: помимо собственно подключения, так же надо обязательно задать режим информирования об ошибках, а так же сообщить базе данных, в какой кодировке нам нужны данные.

### Подключение

Для подключения используется функция `mysqli_connect()` или - в объектном варианте - создание объекта mysqli, `new mysqli()`.
Эта функция принимает несколько параметров, самыми важными из которых являются первые пять:

- **хост**. Имя хоста базы данных. При обучении в подавляющем большинстве случаев это `loacalhost` или `127.0.0.1` что одно и тоже. На боевом сервере имя хоста может быть другим, необходимо узнать его у админа БД или провайдера. 
- **имя пользователя БД**. На домашнем компьютере нет проблем использовать пользователя `root`, но на боевом сервере сайт не работает под рутом никогда. Имя так же надо узнавать у провайдера. 
- **пароль**. На домашнем может быть пустым или `root`, на боевом указывать обязательно.
- **имя базы данных**. Та база данных которую вы создавали в предыдущей главе.
- **порт** (опционально). По умолчанию Mysql работает на порту 3306, однако некоторые готовые сборки программ, особенно на компьютерах Mac, часто используют другой порт. Если он отличается, то его необходимо указать пятым параметром. 

Пример:
```php
$db = new mysqli("127.0.0.1", "root", "root", "yeticave");
```
### Режим информирования об ошибках

Это очень важная опция, которая значительно облегчает работу программиста и сильно упрощает код. 

По умолчанию функции mysqli очень молчаливы, и ничего не сообщают о возникающих ошибках. Это очень неудобно, поскольку сообщения об ошибках позволяют программисту понять, что не так с его кодом. Теоретически можно вызвать специальную функцию, которая вернет сообщение об ошибке, как это часто показано в устаревших материалах, но с этим есть две проблемы: во-первых, нам эта функия нужна только если ничего не работает. А если работает - то не нужна. Так и бегать всё время, то добавлять её, то убирать? А во-вторых - ну банально зачем вообще самому совершать какие-то действия, если они можгут выполняться автоматически? Поэтому надо просто один раз перед соединением задать режим информирования об ошибках, и больше этим вопросом себе голову не забивать. Работы меньше, код - чище.

Для задания режима информирования об ошибках служит функция `mysqli_report()`. В качестве аргумента она принимает комбинацию флагов. Наиболее удобной комбинацией является `MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT`, которая заставит mysqli выбрасывать исключения при возникновении ошибок MySQL. 

Пример:
```php
mysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);
```
(поскольку это единственный случай, когда процедурный синтаксис проще объектного, то мы будем использовать именно его)

### Указание кодировки

Важно понимать, что Mysql поддерживает работу с множеством кодировок и умеет перекодировать данные из одной кодировки в другую на лету. Что может привести к проблемам, если БД будет думать что данные в одной кодировке, а на самом деле они в другой (и тогда в БД появляются "вопросики" и "кракозябры"). Поэтому при соединении с БД всегда надо явно указать кодировку, в которой мы  отправляем данные в БД и в какой хотим получать их обратно. Поскольку стандартом де-факто в настоящее время является кодировка UTF-8, то указывать надо именно её. В MySQL кодировка, полностью поддерживающая стандарт UTF-8 называется `utf8mb4`.

Пример:
```php
$db->set_charset("utf8mb4")
```

# Пример подключения
```php
$db_host = '127.0.0.1';
$db_username = 'root';
$db_password = '';
$db_database = 'yeticave';
$db_port = 3306;
$db_charset = "utf8mb4";

mysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);
$db = new mysqli($db_host, $db_username, $db_password, $db_database, $db_port);
$db->set_charset($db_charset);
```
Здесь мы собрали все команды, описанные выше, воедино, плюс вынесли все настройки в переменные, что в последствии облегчит работу с БД сразу с нескольких компьютеров.

# Работа над ошибками

При ошибке подключения данный код самостоятельно сообщит об ошибке, например

```
PHP Fatal error:  Uncaught mysqli_sql_exception: Access denied for user 'root'@'localhost' (using password: YES) 
in C:\SERVER\www\yeticave\bootstrap.php:10
Stack trace:
#0 C:\SERVER\www\yeticave\bootstrap.php(10): mysqli->__construct('127.0.0.1', 'root', '12', 'yeticave', 3306)
#1 {main}
  thrown in C:\SERVER\www\yeticave\bootstrap.php on line 10
```

В данном случае ошибка означает, что был указан неверный пароль. 

Вообще, при возникновении ошибок, очень важно уметь их читать. поэтому разберем данное сообщение подробно.

 - `PHP Fatal error:  Uncaught mysqli_sql_exception:`  - это стандартный текст который не несёт никакой полезной информации (хотя иногда имя исключения может пригодиться)
 - `Access denied for user 'root'@'localhost' (using password: YES)` - собственно текст ошибки, который пришел из MySQL. Самая важная часть. Вообще при получении любого сообщения об ошибке, если оно сразу непонятно, то очень полезно поискать его в интернете. Надо взять эту часть (в данном случае "Access denied for user 'root'@'localhost' (using password: YES)") и вставить в адресную строку браузера. поскольку большинство оибок являются типовыми, то тут же найдется и объяснение, и рекомендации к исправлению. 
- `in C:\SERVER\www\yeticave\bootstrap.php:10` показывает точное место, где произошла ошибка, имя файла и через двоеточие, номер строки. Для ошибки соединения с БД это не очень важно, но при ошибках запросов это будет незаменимой информацией, поскольку покажет, какой конкретно запрос вызвал ошибку.
- `Stack trace:` последовательность действий, которая привела в ошибке. Хотя в небольших проектах обычно достаточно имени файла и строки, гдепроизошла ошибка, в больших проектах со сложной структурой проблема может возникнуть ранее по коду, а привести к ошибке уже после. С помощью списка вызывавшихся функций можно будет найти проблемое место.

# Последовательность работы с MySQL из PHP-сценария

Вначале нужно выполнить подключение к серверу базы данных, и затем можно выполнять SQL запросы. 

Если взглянуть на взаимодействие MySQL и PHP с позиции пользователя сайта, то все действия, происходящие внутри PHP-сценария, укладываются в некую типовую для любого сценария последовательность

![](https://up.htmlacademy.ru/assets/intensives/php/12/book/images/image-20200320115539808.png)

То есть в самом начале создаём подключение, присваивая значение переменной `$db` и затем эта переменная используется для выполнения запросов на всем протяжении скрипта. 

> **Важно!** Соединение с одной и той же БД всегда должно быть строго одно. Ни в коем случае не следует создавать несколько соединений, и тем более не следует соединяться в каждой функции заново. Если внутри функции требуется соединение с БД, то его надо пердать в эту функцию как один из параметров, например:
```php
function get_bids($db, $log_id) {
   // выполняем запросы, используя $db
}
```

# Закрытие соединения

В большинстве случаев закрывать соединеие с БД не нужно. После завершения работы скрипта РНР закрывает все открытые в нем ресурсы автоматически, в том числе и соединение с БД. То есть в 99% случаев закрывать вручную не нужно. Только в ислючительных случаях можно воспользоваться функцией `$db->close()`.



