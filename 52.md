# Глава 5.2. Выполнение запросов

Все запросы, которые выполняются из РНР, можно разделить на две большие группы - те, в которых не используются переменные, и те, в которые надо подставлять какие-либо данные. Выполняются эти запросы совершенно разными способами.

Также можно разделить запросы на выборку данных (строго говоря, именно эти запросы и называются SQL), и запросы, которые меняют данные в БД (они еще называются DML). С точки зрения РНР между ними нет особенной разницы, просто для первых после выполнения запроса надо еще запросить полученный результат. 

# Запросы, в которых не используются переменные

Это самый простой вариант, и практически не отличается от того, как мы работали с запросами через клиента. Для таких случаев используется функция `mysqli_query()` (и её объектый вариант - просто `query()`). Мы просто берём готовый SQL запрос, например
```SQL
INSERT INTO users SET email = 'developer@php.net', password = 'hash'
```
помещаем его в переменную РНР, и выполняем  с помощью данной функции, используя переменную `$db`, полученную при соединении:
```php
$sql = "INSERT INTO users SET email = 'developer@php.net', password = 'hash'";
$db->query($sql);
```

Эта функция также возвращает результат своего выполнения. Для DML запросов результат может быть `true` или `false`, и нам он не интересен, а для запросов на выборку данных, таких как SELECT и некоторых других, возвращается ссылка на результат, из которой можно получить строки, которые вернула БД:

```php
$sql = "SELECT * FROM categories";
$result = $db->query($sql);
```

# Получение строк, которые вернул запрос. 

Самым основным, базовым вариантом получения результата запроса в РНР является выборка одной строки результата. Причём этот вариант используется как в случае, если мы ожидаем от БД только одну строку, так и если несколько. Во втором случае функция получения строки просто вызывается несклько раз, последовательно в цикле. 

Таких функций в mysqli несколько, и они отличаются тем, как мы обращаемся к отдельным полям запроса, однако самой часто используемой является `mysqli_fetch_assoc()`, которая возвращает ассоциативный массив, её мы и будем использовать в примерах.

### Получение единственной строки

Если нам надо получить из результата одну-единственную строку, то мы просто обращаемся к этой функции и получаем ассоциативный массив, к элементам которого можно потом обращаться для вывода информации:

```php
$sql = "SELECT * FROM categories WHERE code='boards'";
$result = $db->query($sql);
$row = $result->fetch_assoc();
echo "Категория: {$row['name']}";
```
Как видно, имена ключей в массиве совпадают с именами полей в таблице, что очень удобно.

### Получение нескольких строк в цикле

Это очень интересная тема, поскольку для получения нескльких строк служит та же самая функция, что и для оплучения одной строки. Весь секрет тут в том, что каждый последующий вызов функции fetch_assoc (и её собратьев) *перемещает внутренний указатель в результате запроса на следующую строку*. Nо есть если написать такой код,

```php
$sql = "SELECT * FROM categories";
$result = $db->query($sql);
$row = $result->fetch_assoc();
echo "1-я Категория: {$row['name']}";
$row = $result->fetch_assoc();
echo "2-я Категория: {$row['name']}";
```
То он нам вернёт названия двух первых категорий. 

Но конечно же, так писать по сто раз одно и то же никто не будет. И здесь нам напомощь придёт цикл. И тот фкт, что когда fetch_assoc переберт все строки, то вместо следующей строки она вернёт `null`. И этот факт мы можем использовать для органицации цикла `while()`:

```php
$sql = "SELECT * FROM categories";
$result = $db->query($sql);
while ($row = $result->fetch_assoc()) {
    echo "Категория: {$row['name']}<br />\n";
}
```
Здесь цикл будет выполняться до тех пор, пока в $row возвращается массив, и прекращает выполнение, когда приходит null. 
То есть такой цикл переберёт все записи и завершится!

### Получение нескольких строк в массив

Но поскольку в современном веб-приложении мы **никогда* не выводим данные напрямую из БД, а всегда выводим только в шаблоне, то вместо вывода нам надо собирать полученные строки в массив. Это просто:
```php
$sql = "SELECT * FROM categories";
$result = $db->query($sql);
$data = []; // всегда надо инициализировать пустой массив
while ($row = $result->fetch_assoc()) {
    $data[] = $row;
}
```
Таким образом мы получим массив, состоящий из всех строк, которые вернула БД. 

Код получился довольно длинный, но к счастью, в mysqli есть удобная функция, `fetch_all()`, которая может вернуть массив за один раз. В качестве параметра она принимает две константы, которые определяют конечный вид получаемый строк - `MYSQLI_ASSOC` для ассоциативного массива и `MYSQLI_NUM` - для нумерованного:
```php
$sql = "SELECT * FROM categories";
$result = $db->query($sql);
$data = $result->fetch_all(MYSQLI_ASSOC);
```
Но при этом следует понимать, что разницы, кроме количества кода, тут никакой - "под капотом" у этой функции ровно тот же самый цикл `while`. 

Так же следут помнить, что `fetch_all()` пригодится только если нас устроит результат запроса "как есть" - нумерованный массив, содержащий все строки по порядку.
Если нам требуется предварительная обработка получаемых строк, то стоит вернуться к предыдущему варианту.

Так же цикл `while` используется для обработки больших объемов данных. На веб-страницах, показываемых пользователю, таких объемов в принципе быть не должно, но если у нас утилита командной строки, которая должна перебрать все строки из таблицы в которой хранятся записи миллиона пользователей, то тут только в цикле!

# Запросы с использованием переменных

Такие запросы - совершенно особая статья, и это очень важный момент. 

Дело в том что SQL запрос - это пусть и небольшая, но настоящая программа, со своим синтаксисом. И добавляя в программу элементы на лету, можно нарушить синтаксис, что в *лучшем* случае приведёт к ошибкам, а в худшем - к уязвимости, называемой "SQL инъекция", когда нехороший человек подставит в наш запрос свои команды и будет делать в базе данных всё что захочет. Поэтому любые переменные необходимо **передавать в БД отдельно от запроса**. Это делается с помощью подготовленных, или, как их ещё называют, параметризованных запросов.

Чтобы выполнить параметризованный запрос, необходимо выполнить 4 действия:

1. Заменить все переменные в запросе на специальные маркеры, которые называются *плейсхолдеры* или *параметры*, а по сути - просто знаки вопроса
2. Подготовить запрос к исполнению с помощью функции `prepare()`
3. Привязать переменные к запросу с посощью функции `bind_param()`
4. Это 



