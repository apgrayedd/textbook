# Глава 5.2. Выполнение запросов

Все запросы, которые выполняются из РНР, можно разделить на две большие группы - те, в которых не используются переменные, и те, в которые надо подставлять какие-либо данные. Выполняются эти запросы совершенно разными способами.

Также можно разделить запросы на выборку данных (строго говоря, именно эти запросы и называются SQL), и запросы, которые меняют данные в БД (они еще называются DML). С точки зрения РНР между ними нет особенной разницы, просто для первых после выполнения запроса надо еще запросить полученный результат. 

# Запросы, в которых не используются переменные

Это самый простой вариант, и практически не отличается от того, как мы работали с запросами через клиента. Для таких случаев используется функция `mysqli_query()` (и её объектый вариант - просто `query()`). Мы просто берём готовый SQL запрос, например
```SQL
INSERT INTO users SET email = 'developer@php.net', password = 'hash'
```
помещаем его в переменную РНР, и выполняем  с помощью данной функции, используя переменную `$db`, полученную при соединении:
```php
$sql = "INSERT INTO users SET email = 'developer@php.net', password = 'hash'";
$db->query($sql);
```
И у нас в БД появляется новая запись! (Если, конечно, при записи не произошла ошибка).

Эта функция также возвращает результат своего выполнения. Для DML запросов результат может быть `true` или `false`, и нам он не интересен, а для запросов на выборку данных, таких как SELECT и некоторых других, возвращается ссылка на результат, из которой можно получить строки, которые вернула БД:

```php
$sql = "SELECT * FROM categories";
$result = $db->query($sql);
```

# Получение строк, которые вернул запрос. 

Для получения результатов запроса используется специальная переменная, коорая является экземпляром класса `mysqli_result`. Все функции получения строк работают именно с ней. 
Самым основным, базовым вариантом выборки полученных данных, является выборка одной строки результата. Причём этот вариант используется и если мы запрашивали только одну строку, так и если несколько. Во втором случае функция получения строки просто вызывается несклько раз, последовательно в цикле. 

Таких функций в mysqli несколько, и они отличаются тем, как мы обращаемся к отдельным полям запроса, однако самой часто используемой является `mysqli_fetch_assoc()`, которая возвращает ассоциативный массив, её мы и будем использовать в примерах.

### Получение единственной строки

Если нам надо получить из результата одну-единственную строку, то мы просто обращаемся к этой функции и получаем ассоциативный массив, к элементам которого можно потом обращаться для получения информации:

```php
$sql = "SELECT * FROM categories WHERE code='boards'";
$result = $db->query($sql);
$row = $result->fetch_assoc();
echo "Категория: {$row['name']}";
```
Как видно, имена ключей в массиве совпадают с именами полей в таблице, что очень удобно.

### Получение нескольких строк в цикле

Это очень интересная тема, поскольку для получения нескльких строк служит та же самая функция, что и для оплучения одной строки. Весь секрет тут в том, что каждый последующий вызов функции fetch_assoc (и её собратьев) *перемещает внутренний указатель в результате запроса на следующую строку*. То есть если написать такой код,

```php
$sql = "SELECT * FROM categories";
$result = $db->query($sql);
$row = $result->fetch_assoc();
echo "1-я Категория: {$row['name']}";
$row = $result->fetch_assoc();
echo "2-я Категория: {$row['name']}";
```
То он нам вернёт названия двух первых категорий. 

Но конечно же, так писать по сто раз одно и то же никто не будет. И здесь нам напомощь придёт цикл. И тот факт, что когда `fetch_assoc()` переберёт все строки, то вместо следующей строки она вернёт `null`. И этот факт мы можем использовать для органицации цикла `while()`:

```php
$sql = "SELECT * FROM categories";
$result = $db->query($sql);
while ($row = $result->fetch_assoc()) {
    echo "Категория: {$row['name']}<br />\n";
}
```
Здесь цикл будет выполняться до тех пор, пока в $row возвращается массив, и прекращает выполнение, когда приходит null. 
То есть такой цикл переберёт все записи и завершится!

### Получение нескольких строк в массив

Но поскольку в современном веб-приложении мы **никогда** не выводим данные напрямую из БД, а всегда выводим только в шаблоне, то вместо вывода нам надо собирать полученные строки в массив. Это просто:
```php
$sql = "SELECT * FROM categories";
$result = $db->query($sql);
$data = []; // всегда надо инициализировать пустой массив
while ($row = $result->fetch_assoc()) {
    $data[] = $row;
}
```
Таким образом мы получим массив, состоящий из всех строк, которые вернула БД. 

Код получился довольно длинный, но к счастью, в mysqli есть удобная функция, `fetch_all()`, которая может вернуть массив за один раз. В качестве параметра она принимает одну из двух констант, которые определяют конечный вид получаемых строк - `MYSQLI_ASSOC` для ассоциативного массива и `MYSQLI_NUM` - для нумерованного:
```php
$sql = "SELECT * FROM categories";
$result = $db->query($sql);
$data = $result->fetch_all(MYSQLI_ASSOC);
```
Но при этом следует понимать, что разницы, кроме количества кода, тут никакой - "под капотом" у этой функции ровно тот же самый цикл `while`. 

Так же следут помнить, что `fetch_all()` пригодится только если нас устроит результат запроса "как есть" - нумерованный массив, содержащий все строки по порядку.
Если нам требуется предварительная обработка получаемых строк (например изменить индексы массива с чисел по возрастанию на значение их БД), то стоит вернуться к предыдущему варианту.

Так же цикл `while` используется для обработки больших объемов данных. На веб-страницах, показываемых пользователю, таких объемов в принципе быть не должно, но если у нас утилита командной строки, которая должна перебрать все строки из таблицы в которой хранятся записи миллиона пользователей, то тут только в цикле по одной!

# Запросы с использованием переменных

Такие запросы - совершенно особая статья, и это очень важный момент. 

Дело в том что SQL запрос - это пусть и небольшая, но настоящая программа, со своим синтаксисом. И добавляя в программу элементы на лету, можно нарушить синтаксис, что в *лучшем* случае приведёт к ошибкам, а в худшем - к уязвимости, называемой "SQL инъекция", когда нехороший человек подставит в наш запрос свои команды и будет делать в базе данных всё что захочет. Поэтому любые переменные необходимо **передавать в БД отдельно от запроса**. Это делается с помощью подготовленных, или, как их ещё называют, параметризованных запросов.

Чтобы выполнить параметризованный запрос, необходимо выполнить 4 действия:

1. Заменить все переменные в запросе на специальные маркеры, которые называются *плейсхолдеры* или *параметры*, а по сути - просто знаки вопроса
2. Подготовить запрос к исполнению с помощью функции `prepare()`. Эта функция принимает строку запроса и возвращает экземпляр специального класса `mysqli_stmt`, с которым в дальнейшем и производятся все манипуляции
3. Привязать переменные к запросу с помощью `bind_param()`. Это очень интресная функция. Она принимает в качестве параметров все переменные, которые должны попасть в запрос, в том же самом порядке, в котором стоят плейсхолдеры в запросе. Но кроме того, сначала в этой функции должны быть указаны типы для всех переменных, в виде строки, где тип переменной обозначается одной буквой. То есть букв в этой строке должно быть ровно столько, сколько дальше будет переменных. К счастью, можно особо не париться с типами и для всех переменных указывать тип "s". 
4. Выполнить запрос с помощью с помощью `execute()`. Эта функция выполняется без параметров

На словах это звучит длинно, но на практике не так сложно: представим, что у нас есть две переменные, `$email` и `$hash`, которые нам надо записать в таблицу `user`:
```php
$sql = "INSERT INTO users SET email = ?, password = ?"; // заменяем на знаки вопроса
$stmt = $db->prepare($sql); // подготавливаем запрос, получаем stmt
$stmt->bind_param("ss", $email, $hash); // два знака вопроса - две переменных - две буквы s
$stmt->execute(); // выполняем запрос
```
Не так уж и сложно, учитывая что такой подход **гарантирует** нас от ошибок синтаксиса и инъекций. 

Если на любом из этих этапов произойдет ошибка, то mysqli проинформирует нас о ней, благодаря режиму, который мы включили в предыдущей главе.

### Получение результата подготовленного запроса

Для получения строк, которые вернул подготовленный запрос, служит специальная функция `get_result()`. Она возвращает уже знакомую нам переменную типа `mysqli_result` из которой мы уже можем получить сами строки:
```php
$sql = "SELECT * FROM lots WHERE id=?"; // заменяем на знаки вопроса
$stmt = $db->prepare($sql); // подготавливаем запрос, получаем stmt
$stmt->bind_param("ss", $email, $hash); // два знака вопроса - две переменных - две буквы s
$stmt->execute(); // выполняем запрос
$result = $stmt->get_result(); // получаем result
$lot = $result->fetch_assoc(); // получаем строку или массив или перебираем по одной, как показано выше
```

И дальше уже мы работаем с результатом запроса так как было показано выше

# Упрощение работы с подготовленными выражениями

И всё же писать по 4 строчки на каждый запрос - это как-то очень занундно.

К счастью, нашей профессией является программирование, а это значит что мы можем сами для себя создавать какие угодно инструменты для упрощения каких угодно операций. 

В частности, мы вполне можем написать функцию, которая сделает подготовленные запросы такими же простыми в использовании, как и запросы без переменных.

> **Важно!** Написание той функции будет представлять из себя отдельную, дополнительную задачу, по окончании работы над заданием.  Ни в коем случае нельзя применять её с самого начала. Необходимо сначала освоить исходный синтаксис подготовленных выражения. Выполнение этой задачи не является обязательным, при эелании её можно пропустить. 

На самом деле в коде проекта, в файле helpers.php, уже есть пример такой функции, но на мой вгляд она просто чудовищная: неимоверно раздута, с кучей лишнего кода с одной стороны, но при этом не включает в себя нужный код с другой. Не говоря уже о таких ужасных вещах, как вывод ошибок прямо на экран, что опять же является признаком ученического, а не профессионального подхода. Эта функция явно писалась студентом под себя, совершенно без учета того факта, что она может когда-нибудь использоваться на боевом сайте: **посетителю сайта** совершенно неинтересно читать про то, что программисту "Не удалось инициализировать подготовленное выражение". Такого рода ошибки **никогда** не должны выводиться на экран. И почему в курсе для них сделано исключение, остаётся для меня загадкой.    
Не говоря уже о том, что мы при подключении уже задали режим выбороса ошибок mysqli, и вручную проверять ошибки просто не нужно.

Так же в коде функции есть много дугого лишнего кода, например попытка определить тип переменной. Этого делать никогда не надо, по двум причинам

- во-первых, это не нужно. Mysql с огромным удовольствием примет любые данные как строки. 
- во-вторых, такое "вынюхивание" типа может привести к совершенно катастрофическим последствиям. Дело в том, что как и в РНР, в mysql используется слабая типизация. И в частности любая строка равна числу ноль. А это значит, что запрос вида `"delete from users where email=0` **удалит всех пользователей** в таблице! В то время как запрос `delete from users where email='0'` не удалит ни одной строки. Как говорят англичане, "Better safe than sorry", что можно перевести как "Лучше подстраховаться, чем потом пожалеть". И забыть про вынюхивание типа переменной как страшный сон. А просто всегда привязывать все переменные с типом `s`.

На тот редкий случай, когда надо будет указать какой-то другой тип, отличный от s, мы просто добавим к функции необязательный параметр, в котором можно будет указать типы вручную

Ну и напоследок, мы включим в состав функции исполнение запроса, поскльку писать его отдельно не имеет ни малейшего смысла. 

Важно! Функция **не** должна возвращать  результат get_result(). По той простой причине, что она будет использоваться не только для запросов SELECT, а у запросов на вставку или обновление никакого result нету. Посто возвращаем $stmt.



