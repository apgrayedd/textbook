# SQL инъекции

Тема в основном интересна просто нереальным количеством заблуждений, с ней связанных. В чем отметился и основной учебник, о чем будет отдельно сказано ниже.

Само по себе понятие инъекции не представляет из себя ничего сложного:   
Поскольку SQL запрос представляет из себя программу на языке SQL, и мы формируем эту программу динамически, добавляя в неё элементы на лету, то эти элементы могут повлиять на синтаксис программы, и привести - в лучшем случае - к ошибкам, а в худшем - к намеренной манипуяцией запросом. 

### Пример

Пример такой манипуляции показан в известнейшем комиксе, https://xkcd.ru/327/

Допустим, РНР код выглядит так - мы просто подставляем переменную 

    $SQL = "INSERT INTO Students VALUES ('$Name')";
    
а в $name у нас будет `Robert'); DROP TABLE Students; -- ` и запрос получится вот такой

    INSERT INTO Students VALUES ('Robert'); DROP TABLE Students; -- ');
    
что здесь происходит?

- сначала в $name идет имя, хотя это и не обязательно - можно было бы сразу поставить закрывающую кавычку. Добавлено для художественности
- затем одинарная кавычка, которая закрывает строковый элемент
- затем идет скобка, которая закрывает оператор VALUES
- затем точка с запятой, которая завершает запрос
- затем пишется вредоносный запрос `DROP TABLE Students;`
- затем идет оператор комментария `-- `, текст после которого игнорируется базой данных, чтобы эти остатки не помешали второму запросу (можно, кстати, обойтись и без них)
- затем идут остатки оригинального запроса, `');`, которые, как было сказано выше, просто игнорируются

И хотя применимость данного запроса в конкретных условиях - это отдельный вопрос, в качестве иллюстрации *уязвимости* он подходит идеально.   
поскольку очень важно различать два понятия: саму уязвимость, и *конкретный эксплойт*. Эти два понятия постоянно путают, и это порождает полный хаос в рассуждениях.

Разумеется, конкретный эксплойт выглядит гораздо эффектнее. А, главное, можно жонглировать загодочными терминами - "слепая инъекция", "инъекция второго порядка", "инъекция базирующаяся на времени отклика"... Вот только дело в том, что это всё - эксплойты. Которые с точки зрения защиты нам совершенно **не интересны**. Хуже того - попытки защищаться от эксплойтов приводят к совершенно идиотским идеям типа запрещать во входящих данных смивол комментария, слово delete и пр. Это всё полная чушь, которая мало того что не имеет ни малейшего смысла, не только ухудшает функционал приложения (ну что это за база данных, которая не разрешает хранить определённые слова? ) но и является фатальной с точки зрения защиты: количество эксплойтов по определению бесконечно, и защитившись от десяти, мы пропустим одиннадцатый. 

**Защищаться надо не от эксплойтов, а от инъекции.** То есть предотвращать *саму возможность* модифицировать код запроса.  

И если мы защитимся от самого факта инъекции, то все эти красивые слова, и миллионы хитроумных эксплойтов рассыпятся в прах, станут безобидным мусором. То есть наша защита будет этаким Нео, который не глядя отмахивается от летящих со всех сторон пуль.

### Защита

Защита от SQL инъекций сводится к строгосу следованию двум пунктам

1. Любые *данные* должны добавляться в запрос **только** через плейсхолдеры
2. Любые другие элементы запроса должны выбираться из *белого списка* - заранее прописанных в нашем коде значений.

Про первое мы говорили в главе 5.2, а на втором надо остановиться подробнее.    
Бывает так, что нам надо доавить в запрос переменную, которая сдержит не данные, а, скажем, имя поля. В этом случае замена на плейсхолдер не сработает (и скажет об этом сразу), а строковое экранирование поможет как мёртвому припарки, и будет пропускать все возможные инъекции (но мы об этом узнаем только постфактум). 

К счастью, в случае имен полей/команд SQL, список возможных вариантов заведомо ограничен. 

### Заблуждения

С защитой так же связано огромное количество заблуждений, мифов, и суеверий.

Самое, пожалуй, катастрофическое - как по распространённости, так и по последствиям - это утверждение, что функция `mysqli_real_escape_string()` *предназначена* для защиты от инъекций. На самом деле это полная чушь, к инъекциям эта функция имеет косвенное отношение, но главное - никогда не должна применяться в целях защиты.

- самый больший вред приносят рассуждения. концентрируясь на деталях, многие допускают ошибку, пытаясь бороться против каких-то косвенных деталей, вместо того чтобы защищаться от инъекций. И особняком в жтом ряду стоят рассуждения о том, какие данные надо защищать, а какие - нет. 

При защите следует исходить из принципа, **Защищать надо запрос, а не данные!** что это за данные, откуда они пришли, насколько безопасны - нас не должно интересовать от слова "совсем". Игнорирование этого принципа рано или поздно приведет к инъекции. Нас всегда должен интересовать только конечный **нкт назначения**а не источник данных. Данные идут в SQL запрос? Защищаем. Простой, как 3 копейки и на 100% эффективный принцип. 



